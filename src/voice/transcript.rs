//! Transcript logging for voice conversations.
//!
//! Captures user speech (STT) and bot responses (TTS) into a
//! formatted stream that can be sent to a Discord text channel
//! or other log sink.

use tokio::sync::mpsc;
use tracing::{debug, info};

/// A single transcript entry representing either user speech or bot response.
#[derive(Debug, Clone, PartialEq)]
pub enum TranscriptEntry {
    /// User speech captured by STT.
    UserSpeech {
        user_id: u64,
        user_name: String,
        text: String,
    },
    /// Bot response generated by the agent.
    BotResponse {
        bot_name: String,
        text: String,
    },
}

/// Format a transcript entry for display.
pub fn format_entry(entry: &TranscriptEntry) -> String {
    match entry {
        TranscriptEntry::UserSpeech { user_name, text, .. } => {
            format!("\u{1f3a4} {}: {}", user_name, text)
        }
        TranscriptEntry::BotResponse { bot_name, text } => {
            format!("\u{1f50a} {}: {}", bot_name, text)
        }
    }
}

/// Background worker that receives transcript entries and logs them.
///
/// In a future step this will post to a Discord text channel;
/// for now it logs via tracing.
pub struct TranscriptWorker {
    rx: mpsc::UnboundedReceiver<TranscriptEntry>,
}

impl TranscriptWorker {
    pub fn new(rx: mpsc::UnboundedReceiver<TranscriptEntry>) -> Self {
        Self { rx }
    }

    /// Run the transcript worker loop until the channel is closed.
    pub async fn run(&mut self) {
        info!("TranscriptWorker started");
        while let Some(entry) = self.rx.recv().await {
            let formatted = format_entry(&entry);
            debug!(formatted, "transcript");
        }
        info!("TranscriptWorker stopped");
    }
}

/// Create a mock transcript sender for testing.
///
/// Returns the sender and a receiver that collects entries for assertions.
pub fn mock_transcript_channel() -> (
    mpsc::UnboundedSender<TranscriptEntry>,
    mpsc::UnboundedReceiver<TranscriptEntry>,
) {
    mpsc::unbounded_channel()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn format_user_speech() {
        let entry = TranscriptEntry::UserSpeech {
            user_id: 1,
            user_name: "Alice".to_string(),
            text: "Hello".to_string(),
        };
        assert_eq!(format_entry(&entry), "\u{1f3a4} Alice: Hello");
    }

    #[test]
    fn format_bot_response() {
        let entry = TranscriptEntry::BotResponse {
            bot_name: "Bot".to_string(),
            text: "Hi there".to_string(),
        };
        assert_eq!(format_entry(&entry), "\u{1f50a} Bot: Hi there");
    }

    #[test]
    fn transcript_entry_equality() {
        let a = TranscriptEntry::UserSpeech {
            user_id: 1,
            user_name: "Alice".to_string(),
            text: "Hello".to_string(),
        };
        let b = a.clone();
        assert_eq!(a, b);
    }

    #[tokio::test]
    async fn transcript_worker_processes_entries() {
        let (tx, rx) = mpsc::unbounded_channel();
        let mut worker = TranscriptWorker::new(rx);

        tx.send(TranscriptEntry::UserSpeech {
            user_id: 1,
            user_name: "Alice".to_string(),
            text: "Hello".to_string(),
        })
        .unwrap();

        tx.send(TranscriptEntry::BotResponse {
            bot_name: "Bot".to_string(),
            text: "Hi".to_string(),
        })
        .unwrap();

        drop(tx); // Close channel to end the loop.

        // Worker should process both entries and exit.
        worker.run().await;
    }

    #[test]
    fn mock_transcript_channel_works() {
        let (tx, mut rx) = mock_transcript_channel();
        let entry = TranscriptEntry::BotResponse {
            bot_name: "Bot".to_string(),
            text: "test".to_string(),
        };
        tx.send(entry.clone()).unwrap();
        let received = rx.try_recv().unwrap();
        assert_eq!(received, entry);
    }
}
